---
description: Use visualization testing for HTML templates to simplify assertions and focus on template logic
globs: **/*_test.go
---

# HTML Template Visualization Testing

## Context
- HTML templates contain complex markup that's difficult to test directly
- Template logic (conditionals, loops) needs thorough testing
- Direct HTML assertions are brittle and hard to maintain

## Requirements
- Convert HTML output to simplified text representation for testing
- Add data-test-icon attributes to elements for easier identification
- Use a visualizeTemplate function to transform HTML into readable text
- Visualize element states (selected, disabled, etc.) with symbols (‚úì, ‚≠ê, etc.)
- Test all conditional logic paths in templates
- Use table-driven tests for multiple template states
- Assert against normalized text output instead of raw HTML
- Format expected output over multiple lines for readability

## Examples
<example>
// Good: Testing template with visualization and state indicators
func TestCardSelection(t *testing.T) {
	// Arrange
	model := domain.NewUIModel()
	model.SelectedCard = Card{Suit: "Spade", Rank: 7}
	
	// Act
	doc := renderTemplate(t, model)
	
	// Assert - Using visualization with multi-line format and state indicators
	expected := `
		Your turn. 
		Table Cards (1) [üëÜ Card-Name ‚≠ê] 
		Your Hand (1) [üëÜ Selected-Card ‚úì]
	`
	actual := visualizeTemplate(doc)
	assert.Equal(t, normalizeWhitespace(expected), actual)
}

// Visualization helper that includes state indicators
func visualizeNode(n *html.Node, output *strings.Builder, depth int, skipElements []string) {
	// Skip elements in the skip list
	if n.Type == html.ElementNode && slices.Contains(skipElements, n.Data) {
		return
	}

	if n.Type == html.ElementNode {
		var testIcon string
		var isSelected bool
		var isCapturable bool

		for _, attr := range n.Attr {
			if attr.Key == "data-test-icon" {
				testIcon = attr.Val
			}
			if attr.Key == "class" {
				if strings.Contains(attr.Val, "selected") {
					isSelected = true
				}
				if strings.Contains(attr.Val, "capturable") {
					isCapturable = true
				}
			}
		}

		// Add visual indicators for element states
		var indicators string
		if isSelected {
			indicators += "‚úì"  // Checkmark for selected
		}
		if isCapturable {
			indicators += "‚≠ê"  // Star for capturable
		}
		
		if indicators != "" {
			output.WriteString(fmt.Sprintf("[üëÜ %s %s] ", testIcon, indicators))
		} else {
			output.WriteString(fmt.Sprintf("[üëÜ %s] ", testIcon))
		}
	}
}
</example>

<example type="invalid">
// Bad: Testing template with direct HTML assertions
func TestCardSelection(t *testing.T) {
	// Arrange
	model := domain.NewUIModel()
	model.SelectedCard = Card{Suit: "Spade", Rank: 7}
	
	// Act
	doc := renderTemplate(t, model)
	
	// Assert - Brittle direct HTML assertions
	assert.Contains(t, doc, `<div class="card spade selected">`)
	assert.Contains(t, doc, `<div class="card-rank">7</div>`)
	assert.Contains(t, doc, `<div class="card-suit">Sette di Spade</div>`)
}
</example> 